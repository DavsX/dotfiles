" vimrc by Davs
" vim-plug {{{
" let g:plug_home = "/opt/vim-plugged"
call plug#begin()
Plug 'rhysd/clever-f.vim'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'Raimondi/delimitMate'
Plug 'godlygeek/tabular'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-rooter'
Plug 'scrooloose/nerdtree'
Plug 'scrooloose/nerdcommenter'
Plug 'jnurmine/Zenburn'
Plug 'altercation/vim-colors-solarized'
Plug 'tpope/vim-endwise'
Plug 'junkblocker/git-time-lapse'
Plug 'benekastah/neomake'
Plug 'DavsX/vim_test_runner', { 'for': 'perl' }
Plug 'Shougo/vimproc.vim', { 'do': 'make' }
Plug 'rust-lang/rust.vim', { 'for': 'rust' }
Plug 'rickhowe/diffchar.vim'

Plug 'fatih/vim-go', { 'for': 'go' }
Plug 'jodosha/vim-godebug', { 'for': 'go' }
Plug 'zchee/deoplete-clang'

Plug 'elixir-editors/vim-elixir'
Plug 'slashmili/alchemist.vim'
Plug 'mhinz/vim-mix-format'

let g:deoplete#sources#clang#libclang_path = "/usr/lib/libclang.so"
let g:deoplete#sources#clang#clang_header ="/usr/include/clang/"

if has('nvim')
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
    Plug 'sebastianmarkow/deoplete-rust', { 'for': 'rust' }
    Plug 'zchee/deoplete-go', { 'do' : 'make', 'for': 'go' }
endif

call plug#end()
" }}}
" Basic settings {{{
if !has('nvim')
    set nocp
    set encoding=utf-8
endif
set history=999                " history size
set lazyredraw                 " don't redraw when executing macros (good performance option)
set ttyfast
set hidden                     " hide buffers instead of closing them
set backspace=indent,eol,start " allow backspace in insert mode
set errorformat=%f:%l:%m
set autowrite
set nobackup
set noswapfile
set scrolloff=3                " when moving vertically set 3 lines to the cursor
set mousehide
set mouse=niv
if v:version > 703
    set number
    set relativenumber
else
    set number
endif
set splitbelow
set splitright
set nojoinspaces
set clipboard^=unnamedplus,unnamed " add two more registers to clipboard
set iskeyword-=:

set switchbuf=useopen,usetab,newtab
set tags=./tags;/
set complete-=i

" Word wrap not in the middle of the word
set formatoptions=l
set lbr

" fast exiting insert mode; the removes the 1sec delay when not in GUI
set timeout timeoutlen=1000 ttimeoutlen=1000
if !has('gui_running')
    set ttimeoutlen=10
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif

if isdirectory($VIM_UNDODIR)
    set undodir=$VIM_UNDODIR
    set undofile
endif

if isdirectory($VIM_SWAPDIR)
    set directory=$VIM_SWAPDIR//
    set swapfile
endif

let g:sh_noisk=1
" }}}
" cmdline {{{
set cmdheight=1 "command line size
set showcmd     "show last command
set wildmenu    "cmdline completition
" }}}
" Leader {{{
let mapleader = ","
let maplocalleader = "\\"
" }}}
" Search {{{
set showmatch
set hlsearch
set incsearch

nnoremap <leader>. :nohl<CR>
nnoremap <leader>> :let @/ = '\<'.expand('<cword>').'\>'\|set hlsearch<CR>
nnoremap <leader>? :let @/ = expand('<cword>')\|set hlsearch<CR>

set ignorecase

" very magic mode for regexes
nnoremap <leader>/ /\v

vnoremap <C-r> :call ReplaceSelection()<CR>
nnoremap <leader>rw viw"hy:s/<C-r>h//g<left><left>
" }}}
" Indents {{{
set autoindent
set copyindent

vnoremap > >gv
vnoremap < <gv

nnoremap > >>
nnoremap < <<
" }}}
" Tabs {{{
set shiftwidth=4  " number of spaces for indenting
set softtabstop=4 " number of spaces for tabs while editing
set shiftround

set list
set listchars=tab:▸\ ,trail:·
" }}}
" NIKE {{{
if filereadable(expand("~") . "/.nike")
    set modelines=0
    set noexpandtab
    set tabstop=4     " number of spaces for tabs
else
    " gives 4 lines for modelines (vim meta at the beginning/end of files)
    set modelines=4
    set tabstop=8     " number of spaces for tabs
    set expandtab
endif
" }}}
" Statusline {{{
set statusline=
set statusline +=%1*\ %n\ %*            "buffer number
set statusline +=%{fugitive#statusline()} "git branch"
set statusline +=%4*\ %<%-.40F%*        "full path
set statusline +=%2*%m%*                "modified flag
set statusline +=%1*%=%5l%*             "current line
set statusline +=%2*/%L%*               "total lines
set statusline +=%1*%4v\ %*             "virtual column number
set statusline +=%2*0x%04B\ %*          "character under cursor
" }}}
" Gui {{{
set ruler
set rulerformat=%m\ [%l/%L\ %v]

set guifont=DejaVu\ Sans\ Mono\ 11

set guioptions=
set guioptions+=a "autoselect
set guioptions+=e "tabs
set guioptions+=g "grey menu items
set guioptions+=i "vim icon
set guioptions+=t "tearoff menu items

set guitablabel=%t          "show only filename in tabs

set t_Co=256
set colorcolumn=100
if filereadable("/tmp/.Xresources_solarized")
    colorscheme solarized
    highlight CursorLine cterm=NONE ctermbg=253
    highlight ColorColumn guibg=#333333 ctermbg=253
else
    colorscheme zenburn
    highlight CursorLine cterm=NONE ctermbg=239
    highlight ColorColumn guibg=#333333 ctermbg=8
endif

" Horizontal split fill chars
set fillchars+=stlnc:-
set fillchars+=stl:-
set fillchars+=vert:\|

if has('gui_running')
    hi VertSplit guifg=fg guibg=bg
else
    hi VertSplit ctermfg=bg ctermbg=fg
endif

hi Search cterm=underline

set title
set noerrorbells
set showmode
" }}}
" Diff {{{
highlight DiffAdd    cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffDelete cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffChange cterm=bold ctermfg=10 ctermbg=17 gui=none guifg=bg guibg=Red
highlight DiffText   cterm=bold ctermfg=10 ctermbg=88 gui=none guifg=bg guibg=Red

set nocursorbind
set noscrollbind
nnoremap <leader>db :windo set scrollbind!<CR>
nnoremap <leader>du :windo diffupdate<CR>
nnoremap <leader>dw :windo set diffopt+=iwhite<CR>
" }}}
" Basic maps {{{
nnoremap ; :
noremap <leader>w :w<CR>
nnoremap qt <C-W><C-C>
nnoremap qw <C-W><C-W>
nnoremap qe :tabprev<CR>
nnoremap qr :tabnext<CR>

vnoremap <leader>jf :!python -m json.tool<CR>
vnoremap <leader>ujf :!perl -MJSON::XS -e 'my $json = do { local $/; <STDIN> }; print encode_json(decode_json($json))'<CR>
vnoremap <leader>xf :!xmllint --format -<CR>
vnoremap <leader>sf :!sqlformat -r -s -<CR>
vnoremap <leader>pf :!perl -e 'use Data::Dumper; my $lines = do { local $/ = undef; <STDIN> }; print Dumper(eval $lines);'<CR>
vnoremap <c-f> "sy/<C-R>s<CR>


" maximize current split
nnoremap qa <C-W>_<C-W><BAR>
" move to next split and maximize it
nnoremap qs <C-W><C-W><C-W>_<C-W><BAR>

" yank line
nnoremap yu yy

"disable ex-mode; run macros instead
nnoremap Q @q
xnoremap Q :normal @q <CR>

"move to matching brace pair
nnoremap <tab> %

"split navigation
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

inoremap <c-f> <c-x><c-f>

nnoremap ds<space> F<space>xf<space>x

nnoremap <leader>tw :%s/\s\+$//e<CR>
" }}}
" Movement maps {{{
" H beginning of line; L end of line
nnoremap H ^
nnoremap L g_

vnoremap H ^
vnoremap L g_

onoremap H ^
onoremap L g_

" j/k move in wrapped lines too
nnoremap j gj
nnoremap k gk

vnoremap j gj
vnoremap k gk

" move to the top/middle/bottom of the screen
nnoremap gt :normal! H<CR>
nnoremap gb :normal! L<CR>
nnoremap gm :normal! M<CR>

nnoremap <c-\> :po<CR>
" }}}
" Row/column highlight {{{
noremap <F2> :call ToggleLineNumbers()<CR>
noremap <F3> :set cursorline!<CR>
noremap <F4> :set cursorcolumn!<CR>
noremap <F6> :set list!<CR>
noremap <f7> :GitGutterToggle<CR>
" }}}
" Tabs {{{
noremap <c-t> :tabnew<CR>
" }}}
" Filetype {{{
" EveryFile {{{
augroup all_file_type
    autocmd!
    if v:version > 703
        autocmd WinEnter,FocusGained,BufEnter * setlocal relativenumber | setlocal number
        autocmd WinLeave,FocusLost,BufLeave * setlocal norelativenumber | setlocal number
    endif
    if !filereadable(expand("~") . "/.nike")
        autocmd BufWritePre * %s/\s\+$//e
    endif

    " Turn off syntax syncing for large files
    autocmd BufEnter * if line2byte(line("$") + 1) > 1000000 | syntax clear | endif

    autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | pclose | endif

    autocmd WinEnter,FocusGained,BufEnter * if &diff | setlocal winwidth=1 | setlocal wrap | setlocal nocursorbind | endif
    autocmd WinEnter,FocusGained,BufEnter * if !&diff | setlocal winwidth=101 | endif

    autocmd Syntax * highlight SpecialKey ctermfg=240 gui=bold guifg=#5b605e
    autocmd Syntax * highlight NonText ctermfg=240 gui=bold guifg=#5b605e

    autocmd BufEnter * let &titlestring = $USER."@".hostname().":".expand("%:p")
augroup END
" }}}
" Elixir {{{
augroup filetype_elixir
    autocmd!
    autocmd BufRead,BufWritePre,FileType elixir silent execute ":Rooter"

    autocmd BufRead,BufNewFile *.ex  if line('$') == 1 && getline('.') == '' | call NewElixirModule() | endif
    autocmd BufRead,BufNewFile *.exs if line('$') == 1 && getline('.') == '' | call NewElixirModule() | endif

    autocmd FileType elixir nnoremap <buffer> <leader>rr :!elixir %<CR>
    autocmd FileType elixir nnoremap <buffer> <leader>rm :!mix<CR>
    autocmd FileType elixir nnoremap <buffer> <leader>ta :!mix test<CR>
    autocmd FileType elixir nnoremap <buffer> <leader>tf :!mix test --no-start %<CR>
    autocmd FileType elixir nnoremap <buffer> <leader>tl :execute ":!mix test ".expand('%').":".line('.')<CR>
augroup END
" }}}
" golang {{{
augroup filetype_golang
    autocmd!
    autocmd FileType go setlocal shiftwidth=4
    autocmd FileType go setlocal tabstop=4
    autocmd FileType go setlocal softtabstop=4

    autocmd BufRead,BufWritePre,FileType go silent execute ":Rooter"

    autocmd BufNewFile *.go 0r ~/.vim/skeleton/go.script

    autocmd FileType go nnoremap <buffer> <leader>dd o<ESC>ifmt.Printf("%+v\n", )<LEFT>
    autocmd FileType go nnoremap <buffer> <leader>de o<ESC>ifmt.Printf("%+v\n")<CR>os.Exit(1)<ESC>:GoImports<CR>k$i,

    autocmd FileType go let g:go_fmt_command = "goimports"
    autocmd FileType go let g:go_fmt_autosave = 0
    autocmd FileType go noremap <buffer> <leader>rr :!go run %<CR>
    autocmd FileType go noremap <buffer> <leader>i :GoInfo<CR>
    autocmd FileType go noremap <buffer> <leader>b :GoBuild<CR>
    autocmd FileType go noremap <buffer> <leader>ts :GoInstall<CR>
    autocmd FileType go noremap <buffer> <leader>gi :GoImports<CR>
    autocmd FileType go noremap <buffer> <leader>tf :GoTestFunc<CR>
    autocmd FileType go noremap <buffer> <leader>ta :GoTest<CR>
    autocmd FileType go noremap <buffer> <leader>aa :GoAlternate<CR>

    autocmd FileType go noremap <buffer> <leader>ger oif err != nil {<CR>return err<CR>}
    autocmd FileType go noremap <buffer> <leader>gel oif err != nil {<CR>log.Fatal(err)<CR>}
    autocmd FileType go noremap <buffer> <leader>get oif err != nil {<CR>t.Fatal(err)<CR>}
    autocmd FileType go noremap <buffer> <leader>gep oif err != nil {<CR>panic("")<CR>}<ESC>k$<LEFT><LEFT>i
augroup END
" }}}
" lua {{{
augroup filetype_lua
    autocmd!
    autocmd FileType lua noremap <buffer> <leader>rr :!lua %<CR>
augroup END
" }}}
" Haskell {{{
augroup filetype_haskell
    autocmd!
    autocmd BufRead,BufWritePre,FileType haskell silent execute ":Rooter"

    autocmd BufRead,BufNewFile *.hs if line('$') == 1 && getline('.') == '' | call NewHaskellModule() | endif

    autocmd BufWritePost * if &filetype=='haskell' | execute ":Neomake" | endif

    autocmd FileType haskell setlocal shiftwidth=2
    autocmd FileType haskell setlocal softtabstop=2
    autocmd FileType haskell setlocal expandtab
    autocmd FileType haskell setlocal formatprg=hindent
    autocmd FileType haskell setlocal equalprg=hindent
    " autocmd FileType haskell setlocal iskeyword=a-z,A-Z,48-57,_,.,39
    autocmd FileType haskell setlocal iskeyword=a-z,A-Z,48-57,_,39

    autocmd FileType haskell let g:haskellmode_completion_ghc = 0

    autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

    autocmd FileType haskell noremap <buffer> <leader>. :HdevtoolsClear<CR>:nohl<CR>
    autocmd FileType haskell noremap <buffer> <F1> :HdevtoolsType<CR>
    autocmd FileType haskell noremap <buffer> <leader>ht :HdevtoolsType<CR>
    autocmd FileType haskell noremap <buffer> <leader>hi :HdevtoolsInfo<CR>
    autocmd FileType haskell command! HdevtoolsKill :!killall hdevtools

    autocmd FileType haskell noremap <buffer> <F12> :!stack exec -- hasktags --ignore-close-implementation --ctags .<CR>

    autocmd FileType haskell noremap <buffer> <leader>rr :!runhaskell %<CR>
    autocmd FileType haskell noremap <buffer> <leader>tw :GhcModTypeInsert<CR>

    autocmd FileType haskell noremap <buffer> <leader>vm :w<CR>:call TmuxSendKeys(":l ".expand('%')."\nmain")<CR>
    autocmd FileType haskell noremap <buffer> <leader>vl :w<CR>:call TmuxSendKeys(":l ".expand('%'))<CR>
    autocmd FileType haskell noremap <buffer> <leader>vs :w<CR>:call TmuxSendKeys("stack ghci --with-ghc intero")<CR>
    autocmd Filetype haskell nnoremap <buffer> <leader>vi vaw"hy<ESC>:call TmuxSendKeys(":info ".@h)<CR> | echo ""
    autocmd Filetype haskell nnoremap <buffer> <leader>vt :call TmuxSendKeys(":type-at ".expand('%')." ".line(".")." ".col(".")." ".line(".")." ".(col(".")))<CR> | echo ""
    autocmd Filetype haskell nnoremap <buffer> <leader>vd vaw<ESC>:call TmuxSendKeys(":loc-at ".expand('%')." ".line("'<")." ".col("'<")." ".line("'>")." ".(col("'>")-1).' "'.expand('<cword>').'"')<CR> | echo ""

augroup END
" }}}
" Rust {{{
augroup filetype_rust
    autocmd!

    autocmd BufWritePost * if &filetype=='rust' | execute ":Neomake" | endif
    autocmd FileType rust nnoremap <buffer> <leader>ta  :!cargo test<CR>
    autocmd FileType rust nnoremap <buffer> <leader>ts  :!cargo check<CR>
    autocmd FileType rust nnoremap <buffer> <leader>rr  :!cargo run<CR>
    autocmd FileType rust noremap <buffer> <F12> :silent! exec ":!rusty-tags vi --quiet &" <CR> | redraw!

    autocmd BufRead *.rs :setlocal tags=./rusty-tags.vi;/,$RUST_SRC_PATH/rusty-tags.vi
augroup END
" }}}
" OCaml {{{
if system("command -v opam") != ""
    let g:opam_share_dir = substitute(system("opam config var share 2>/dev/null"), '[\r\n]*$', '', '')
    execute "set rtp+=" . g:opam_share_dir . "/merlin/vim"
    execute "set rtp+=" . g:opam_share_dir . "/ocp-indent/vim"
    execute "set rtp+=" . g:opam_share_dir . "/ocp-index/vim"
endif

let g:deoplete#omni_patterns = {}
let g:deoplete#omni_patterns.ocaml = '[^. *\t]\.\w*\|\h\w*|#'

augroup filetype_ocaml
    autocmd!

    autocmd BufRead,BufNewFile *.ml  setfiletype ocaml

    autocmd FileType ocaml setlocal shiftwidth=2
    autocmd FileType ocaml setlocal softtabstop=2
    autocmd FileType ocaml setlocal expandtab
    autocmd FileType ocaml let b:delimitMate_quotes = '"'

    autocmd FileType ocaml nnoremap <buffer> <leader>rr :call RunOCaml()<CR>
    autocmd FileType ocaml nnoremap <buffer> <leader>. :MerlinClearEnclosing<CR>:nohl<CR>
    autocmd FileType ocaml nnoremap <buffer> <leader>ts :MerlinErrorCheck<CR>
    autocmd FileType ocaml nnoremap <buffer> <leader>yt :MerlinYankLatestType<CR>
augroup END
" }}}
" Perl {{{
augroup filetype_perl
    autocmd!
    autocmd BufRead,BufNewFile *.pm  setfiletype perl
    autocmd BufRead,BufNewFile *.pl  setfiletype perl
    autocmd BufRead,BufNewFile *.t   setfiletype perl

    autocmd BufNewFile *.pl 0r ~/.vim/skeleton/perl.script
    autocmd BufNewFile *.t 0r ~/.vim/skeleton/perl.test

    autocmd BufRead,BufNewFile *.pm if line('$') == 1 && getline('.') == '' | call NewPerlModule() | endif

    "autocmd BufWritePost * if &filetype=='perl' | call Check_time_since_last_commit() | endif

    autocmd BufRead,BufWritePre,FileType perl silent execute ":Rooter"

    autocmd BufRead,BufNewFile *.pm  setlocal filetype=perl
    autocmd BufRead,BufNewFile *.pl  setlocal filetype=perl
    autocmd BufRead,BufNewFile *.t   setlocal filetype=perl

    autocmd FileType perl setlocal iskeyword-=:

    autocmd FileType perl setlocal nowrap

    autocmd FileType perl syn region perlSubFold start="^\z(\s*\)\<subtest\>.*[^};]$" end="^\z1};\s*$" transparent fold keepend
    autocmd FileType perl syn region perlSubFold start="^\z(\s*\)\<txn_subtest\>.*[^};]$" end="^\z1};\s*$" transparent fold keepend
    autocmd FileType perl hi Statement ctermfg=14

    autocmd FileType perl nnoremap <buffer> <leader>dd <ESC>ause v5.10;<CR>use Data::Dumper;<CR>local $Data::Dumper::Sortkeys = 1;<CR>local $Data::Dumper::Maxdepth = 2;<CR>say STDERR Dumper();<LEFT><LEFT>
    autocmd FileType perl nnoremap <buffer> <leader>dt <ESC>ause v5.10;<CR>use Data::Dumper;<CR>local $Data::Dumper::Terse = 1;<CR>local $Data::Dumper::Indent = 0;<CR>local $Data::Dumper::Sortkeys = 1;<CR>local $Data::Dumper::Maxdepth = 2;<CR>say STDERR Dumper();<LEFT><LEFT>
    autocmd FileType perl nnoremap <buffer> <leader>so <ESC>vapk:sort<CR>

    autocmd FileType perl nnoremap <buffer> <leader>gu :let @/=expand("<cword>")<CR>:!grep -rP '(::<BAR>\->)<c-r>=expand("<cword>")<CR>' bin/ lib/ etc/<CR>
    autocmd FileType perl nnoremap <buffer> <leader>gd :let @/=expand("<cword>")<CR>:!grep -rP 'sub <c-r>=expand("<cword>")<CR>' bin/ lib/ etc/<CR>
    autocmd FileType perl nnoremap <buffer> <leader>ga :let @/=expand("<cword>")<CR>:!grep -rP '<c-r>=expand("<cword>")<CR>' bin/ lib/ etc/ t/<CR>

    autocmd FileType perl nnoremap <buffer> <leader>rr :!perl -Ilib %<CR>

    vnoremap <leader>pt :!perltidy<CR>
    nnoremap <leader>pt :%!perltidy<CR>

    autocmd FileType perl nnoremap <buffer> <leader>ts  :!perl -Ilib -c %<CR>
    autocmd FileType perl nnoremap <buffer> <leader>tf  :PerlTestFile<CR>
    autocmd FileType perl nnoremap <buffer> <leader>tpf :PerlProveTestFile<CR>
    autocmd FileType perl nnoremap <buffer> <leader>ta  :PerlTestAll<CR>
    autocmd FileType perl nnoremap <buffer> <leader>td  :PerlTestDir<CR>
    autocmd FileType perl nnoremap <buffer> <leader>tc  :PerlTestCreate<CR>
    autocmd FileType perl nnoremap <buffer> <leader>to  :PerlTestDirOpen<CR>

    autocmd FileType perl nnoremap gci :call CommitPerlFiles()<CR>

    " autocmd FileType perl nnoremap <buffer> <leader>ps viw"hyouse v5.10; say "<C-r>h: $<C-r>h";<ESC>
    " autocmd FileType perl nnoremap <buffer> <leader>pd viw"hyouse v5.10; use Data::Dumper; say "<C-r>h: ".Dumper($<C-r>h);<ESC>
    autocmd FileType perl nnoremap <buffer> <leader>ps 0f$lviw"hyouse v5.10; say "<C-r>h: $<C-r>h";<ESC>
    autocmd FileType perl nnoremap <buffer> <leader>pd 0f$lviw"hyouse v5.10; use Data::Dumper; local $Data::Dumper::Sortkeys = 1; local $Data::Dumper::Maxdepth = 2;<CR>say "<C-r>h: ".Dumper($<C-r>h);<ESC>
    autocmd FileType perl vnoremap <buffer> <leader>pd :call PerlDumpVariables()<CR>
augroup END
" }}}
" HTML {{{
augroup filetype_html
    autocmd!
    autocmd BufRead,BufNewFile *.tt setfiletype html
    autocmd BufRead,BufNewFile *.tt setlocal foldmethod=marker

    autocmd BufRead,BufWritePre,FileType html silent execute ":Rooter"

    autocmd FileType html setlocal foldlevel=99
    autocmd FileType html setlocal shiftwidth=2
    autocmd FileType html setlocal tabstop=2
    autocmd FileType html setlocal softtabstop=2
    autocmd FileType html setlocal expandtab

    autocmd FileType html highlight link htmlLink text
    autocmd FileType html syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 keepend contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLinkText,javaScript,@htmlPreproc
    autocmd FileType html syn match htmlLinkText contained contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLinkText,javaScript,@htmlPreproc "^\s*\zs.\{-}\ze\s*$"
    autocmd FileType html syn match htmlLinkText contained contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLinkText,javaScript,@htmlPreproc "\S.\{-}\ze\s*$"
    autocmd FileType html highlight def link htmlLinkText Underlined

    autocmd FileType html iabbrev <buffer> nbsp &nbsp;
augroup END
" }}}
" vim {{{
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
    autocmd FileType vim setlocal foldlevel=0
    autocmd FileType vim setlocal expandtab

    autocmd FileType vim noremap <buffer> <leader>ss  :w<CR>:source %<CR>:e <CR>
    autocmd FileType vim noremap <buffer> <leader>rr  :source %<CR>
augroup END
" }}}
" javascript {{{
augroup filetype_js
    autocmd!

    autocmd BufRead,BufWritePre,FileType javascript silent execute ":Rooter"

    autocmd FileType javascript setlocal shiftwidth=2
    autocmd FileType javascript setlocal softtabstop=2
    autocmd FileType javascript setlocal expandtab
    autocmd FileType javascript setlocal foldmethod=indent
    autocmd FileType javascript setlocal foldlevelstart=20
    autocmd FileType javascript let javaScript_fold=1
augroup END
" }}}
" CursorLine {{{
augroup CursorLine
    autocmd!
    autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
augroup END
" }}}
" ruby {{{
augroup filetype_ruby
    autocmd!

    autocmd BufRead,BufWritePre,FileType ruby silent execute ":Rooter"

    autocmd FileType ruby,eruby let ruby_fold = 1
    autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
    autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

    autocmd FileType ruby,eruby setlocal shiftwidth=2
    autocmd FileType ruby,eruby setlocal softtabstop=2
    autocmd FileType ruby,eruby setlocal expandtab

    autocmd FileType ruby nnoremap <buffer> <leader>rr :!ruby %<CR>
augroup END
" }}}
" python {{{
augroup filetype_python
    autocmd!

    autocmd BufRead,BufWritePre,FileType python silent execute ":Rooter"

    autocmd FileType python setlocal shiftwidth=2
    autocmd FileType python setlocal softtabstop=2
    autocmd FileType python setlocal expandtab

    autocmd FileType python nnoremap <buffer> <leader>rr :!python %<CR>
augroup END
" }}}
" Clojure {{{
augroup filetype_clojure
    autocmd!
    autocmd BufRead,BufWritePre,FileType clojure silent execute ":Rooter"

    autocmd Syntax clojure syn match clojureRoundParen "("
    autocmd Syntax clojure syn match clojureRoundParen ")"
    autocmd Syntax clojure RainbowParenthesesActivate
    autocmd Syntax clojure RainbowParenthesesLoadRound
    autocmd Syntax clojure highlight clojureRoundParen cterm=bold

    autocmd FileType clojure let b:delimitMate_quotes = '"'

    autocmd FileType clojure nnoremap <buffer> <leader>rr :call RunClojure(0)<CR>
    autocmd FileType clojure nnoremap <buffer> <leader>re :call RunClojure(1)<CR>

    autocmd FileType clojure nmap <leader>F <Plug>FireplacePrint<Plug>(sexp_outer_top_list)``
    autocmd FileType clojure nmap <leader>f <Plug>FireplacePrint<Plug>(sexp_outer_list)``
    autocmd FileType clojure nmap <leader>e <Plug>FireplacePrint<Plug>(sexp_inner_element)``

    " autocmd FileType clojure nnoremap ( ?[[({]<CR>:nohl<CR>
    " autocmd FileType clojure nnoremap ) /[[({]<CR>:nohl<CR>
augroup END
" }}}
" sh {{{
augroup sh
    autocmd!
    autocmd FileType sh nnoremap <buffer> <leader>rr :!bash %<CR>
augroup END
" }}}
" C {{{
augroup gcc
    autocmd!
    autocmd BufRead,BufWritePre,FileType c silent execute ":Rooter"
    autocmd FileType c nnoremap <buffer> <leader>rr :!gcc -o <C-R>=expand("%:t:r")<CR> % && ./<C-R>=expand("%:t:r")<CR><CR>
    autocmd FileType c nnoremap <buffer> <F12> :silent! exec ":!ctags_gen" <CR> | redraw!
augroup END
" }}}
" Arduino {{{
augroup arduino
    autocmd!
    autocmd BufRead,BufWritePre,FileType arduino silent execute ":Rooter"
    autocmd FileType arduino nnoremap <buffer> <F12> :silent! exec ":!ctags_gen" <CR> | redraw!
augroup END
" }}}
" XML {{{
augroup filetype_xml
    autocmd!
    autocmd BufRead,BufNewFile *.xml.sample  setfiletype xml
augroup END
" }}}
" SLS {{{
augroup filetype_yaml
    autocmd!
    autocmd BufRead,BufNewFile *.sls setfiletype yaml

    autocmd BufRead,BufWritePre,FileType yaml silent execute ":Rooter"
augroup END
" }}}
" vimrc {{{
noremap <leader>se :tabnew $MYVIMRC<CR>
noremap <leader>ss :source $MYVIMRC<CR>
noremap <leader>sl :execute getline(".")<CR>
" }}}
" }}}
" Folding {{{
set foldmethod=indent
set foldlevel=20 "open folds by default

noremap <space> za
" }}}
" Functions {{{
" NewPerlModule {{{
function! NewPerlModule()
    0r ~/.vim/skeleton/perl.package
    let l:path = expand('%:p')
    let l:path = substitute(l:path, '^.*/\(lib\|t\)/', '', '')
    let l:path = substitute(l:path, '.pm$', '', '')
    let l:module_name = substitute(l:path, '/', '::', 'g')
    execute "normal! ggwi".l:module_name
endfunction
" }}}
" NexElixirModule {{{
function! NewElixirModule()
    " get the part between lib/ and .ex
    let l:path = substitute(expand('%:p'), '^.*/\(lib\|test\)/\(.*\).exs\?$', '\2', 'g')

    " not inside 'lib' nor 'test'
    if l:path == expand('%:p')
        let l:path = 'my_module'
    endif

    " insert defmodule and capitalize the first letter of the module name
    execute "normal! gg0idefmodule ".l:path." do\nend\<ESC>gg0W~"

    " delete _, capitalize next letter
    if getline(".") =~# '_'
        :s/\v_(.)/\u\1/g
    endif

    " replace / with ., capitalize next letter
    if getline(".") =~# '/'
        :s/\v\/(.)/.\u\1/g
    endif

    execute "normal! o"
    startinsert
endfunction
" }}}
" NexHaskellModule {{{
function! NewHaskellModule()
    " get the part between lib/ and .ex
    let l:path = substitute(expand('%:p'), '^.*/\(src\|t\)/\(.*\).hs$', '\2', 'g')

    " not inside 'lib' nor 'test'
    if l:path == expand('%:p')
        let l:path = 'Main'
    endif

    0r ~/.vim/skeleton/haskell.module

    execute "normal! gg/module Main\<CR>WcE".l:path."\<ESC>"

    " delete _, capitalize next letter
    if getline(".") =~# '_'
        :s/\v_(.)/\u\1/g
    endif

    " replace / with ., capitalize next letter
    if getline(".") =~# '/'
        :s/\v\/(.)/.\u\1/g
    endif

    execute "normal! j"
    startinsert
endfunction
" }}}
" RunPerlTest {{{
function! RunPerlTest(mode)
    let l:path = expand('%')

    let l:result = 0

    if a:mode == 'file'
        let l:result = RunTest(l:path)
        "elseif a:mode == 'class'
        "let l:class = GetPythonClassName()
        "let l:result = RunTest(l:path . ":" . l:class)
        "elseif a:mode == 'method'
        "let l:class = GetPythonClassName()
        "let l:method = GetPythonMethodName()
        "let l:result = RunTest(l:path .":". l:class .".". l:method)
    else
        let l:result = RunTest('t/')
    endif

    if l:result == 0
        let l:line = getqflist()[0]['text']

        let l:list = matchlist(l:line, '\vFile "([^"]*)", line (\d+)')
        if !empty(l:list)
            let l:file = l:list[1]
            let l:line_no = l:list[2]

            if l:file =~# getcwd()
                if l:file == expand('%:p')
                    execute "normal! ".l:line_no."G"
                else
                    execute "badd +".l:line_no." ".l:file
                    execute "vert sbuffer " . l:file
                    execute "normal! ".l:line_no."G"
                endif
            endif
            copen
            wincmd k
        else
            let l:bufname = fnamemodify(buffer_name(getqflist()[0]['bufnr']), ':p')
            if l:bufname =~# getcwd()
                cc!
            else
                copen
            endif
        endif
    endif
endfunction
" }}}
" CloseHiddenbuffers {{{
nnoremap <leader>cl :call CloseHiddenBuffers()<CR>
function! CloseHiddenBuffers()
    let visible_buffers = {}

    for tab in range(1, tabpagenr('$'))
        for buffer in tabpagebuflist(tab)
            let visible_buffers[buffer] = 1
        endfor
    endfor

    for buffer in range(1, bufnr('$'))
        if bufloaded(buffer) && !has_key(visible_buffers, buffer)
            execute 'bd ' . buffer
        endif
    endfor

    execute "NERDTree | NERDTreeToggle"
endfunction
" }}}
" DeleteFile {{{
function! DeleteFile()
    let l:path = expand('%:p')
    let l:confirm = input('Delete '.l:path.'? [YES]: ')
    if l:confirm ==# 'YES'
        call delete(l:path) | bdelete!
    endif
endfunction
" }}}
" PerlDumpVariables {{{
function! PerlDumpVariables() range
    let l:variable_filter = {}
    let l:variable_order = []

    for line_number in range(a:firstline, a:lastline)
        let l:line = getline(line_number)
        if l:line =~# '\v^\s*#'
            continue
        endif

        let l:variable_name = matchstr(l:line, '\v^\s*(my )?\$\zs([^ =]+)')
        if l:variable_name !=? ''
            if !has_key(l:variable_filter, l:variable_name)
                let l:variable_filter[l:variable_name] = 1
                let l:variable_order += [l:variable_name]
            endif
        endif
    endfor

    execute "normal! ".a:lastline."G"

    execute "normal! o\<ESC>ouse Data::Dumper; local $Data::Dumper::Sortkeys = 1; local $Data::Dumper::Maxdepth = 2;"
    for variable in l:variable_order
        execute "normal! oprint '".variable.": '.Dumper($".variable.");"
    endfor
    execute "normal! o"
endfunction
" }}}
" CommitPerlFiles {{{
function! CommitPerlFiles()
    let l:path = expand("%")
    let l:git_rev = system("git rev-parse --abbrev-ref HEAD 2>/dev/null")
    let l:task_number = matchstr(l:git_rev, '\v(BAC-\d+)')
    let l:msg_prefix = ''

    if l:task_number != ''
        let l:msg_prefix = l:task_number." "
    endif

    if l:path =~# '\v^(bin|lib|t)\/.+(pl|pm|t)?$'
        let l:path = substitute(l:path, '\v(bin|lib|t)/', '', '')
        let l:path = substitute(l:path, '\/', '::', 'g')

        let l:msg_prefix = l:msg_prefix.l:path
        execute "normal! :Gwrite \<BAR> Gcommit\<CR>O".l:msg_prefix." - "
    else
        execute "normal! :let @f=expand('%:t:r')\<CR>:Gwrite \<BAR> Gcommit\<CR>O\<C-R>f - \<space>"
    endif

endfunction
" }}}
" ReplaceSelection {{{
function! ReplaceSelection() range
    let l:line_no = line("'>") - line("'<") + 1
    if l:line_no == 1
        try
            let a_save = @a
            normal! gv"ay
            let l:escaped = escape(@a, '\/')
            let l:escaped = substitute(l:escaped, "\r", '', '')
            let l:escaped = substitute(l:escaped, "\n", '', '')
            call feedkeys(":\<c-u>%s/\\V".l:escaped."//gc\<LEFT>\<LEFT>\<LEFT>", 'n')
        finally
            let @a = a_save
        endtry
    else
        echo "More than 1 line selected!"
    endif
endfunction
" }}}
" TmuxSendKeys {{{
let g:tmux_pane_id = ""
if filereadable("/tmp/.vim_tmux_pane_id")
    let g:tmux_pane_id = readfile("/tmp/.vim_tmux_pane_id")[0]
endif
function! TmuxSendKeys(str)
    if g:tmux_pane_id == ""
        echo "set g:tmux_pane_id with the id of the TMUX pane or set \$VIM_TMUX_PANE_ID"
    else
        call system("tmux send-keys -t".g:tmux_pane_id." \"".a:str."\" Enter")
    endif
endfunction
" }}}
" ToggleLineNumbers {{{
function! ToggleLineNumbers()
    if &number
        set nonumber
        set norelativenumber
    else
        set number
        set relativenumber
    endif
endfunction
" }}}
" RunOCaml {{{
function! RunOCaml()
    execute "normal! :!corebuild -no-links \<C-r>=expand('%:r')\<CR>.byte --\<CR>"
endfunction
" }}}
" }}}
" Plugin settings {{{
" Tabularize {{{
vnoremap <leader>ah :Tabularize /^.\{-}\zs=>/l1l1<CR>
vnoremap <leader>a= :Tabularize /^.\{-}\zs=\(>\)\@!/l1l1<CR>
vnoremap <leader>a, :Tabularize /^.\{-}\zs,/l1l1<CR>
vnoremap <leader>aa :Tabularize /
vnoremap <leader>af :Tabularize /^.\{-}\zs/l1l1<left><left><left><left><left>

nnoremap <leader>ah :Tabularize /^.\{-}\zs=>/l1l1<CR>
nnoremap <leader>a= :Tabularize /^.\{-}\zs=\(>\)\@!/l1l1<CR>
nnoremap <leader>a, :Tabularize /^.\{-}\zs,/l1l1<CR>
nnoremap <leader>aa :Tabularize /
nnoremap <leader>af :Tabularize /^.\{-}\zs/l1l1<left><left><left><left><left>
" }}}
" ctrlp {{{
set runtimepath^=~/.vim/bundle/ctrlp.vim
let g:ctrlp_switch_buffer = 'Et'
let g:ctrlp_regexp = 0
let g:ctrlp_by_filename = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_custom_ignore = {
            \ 'dir': '\v(\.git|venv|deps|_build)',
            \ 'file': '\v(__init2__\.py|\.pyc)$',
            \ }

nnoremap <leader>, :CtrlP<CR>
" }}}
" Clever-f {{{
let g:clever_f_across_no_line = 0
" }}}
" Rooter {{{
let g:rooter_patterns = [ '.vimproject', '.git/' ]
let g:rooter_manual_only = 0
let g:rooter_change_directory_for_non_project_files = 0
" }}}
" snippets {{{
let g:snips_author = "David Kovacs [DavsX]"
let g:snips_email = "kovdavid@gmail.com"
let g:snips_github = "http://github.com/DavsX"
" }}}
" test_class_runner {{{
let $TAP_ELAPSED_FORMAT  = '%t1 elapsed'
let g:perl_test_args_perl   = '-It/lib -Ilib'
let g:perl_test_args_prove  = '-It/lib -Ilib -r -j9 --timer'
let g:perl_test_all_command = 'prove'
" }}}
" NERDTree {{{
function! NERDTreeFindToggle()
    if &filetype=='nerdtree'
        execute 'NERDTreeClose'
    else
        if (exists("t:NERDTreeBufName") && bufwinnr(t:NERDTreeBufName) != -1)
            execute 'NERDTreeClose'
        else
            execute 'NERDTreeFind'
        endif
    endif
endfunction
nnoremap <F5> :call NERDTreeFindToggle()<CR>

let NERDTreeIgnore = ['\.pyc$']
let NERDTreeChDirMode=0
" }}}
" Fugitive {{{
nnoremap gst :Gstatus<CR>5j
nnoremap gd :Gvdiff<CR>
nnoremap gci :let @f=expand("%:t:r")<CR>:Gwrite <BAR> Gcommit<CR>O<C-R>f:<space>
nnoremap gca :Gwrite <BAR> Gcommit --amend<CR>ggA
" }}}
" supertab {{{
let g:SuperTabDefaultCompletionType="<c-x><c-o>"
let g:SuperTabClosePreviewOnPopupClose=1

if has("gui_running")
    imap <c-space> <c-r>=SuperTabAlternateCompletion("\<lt>c-x>\<lt>c-o>")<cr>
else " no gui
    if has("unix")
        inoremap <Nul> <c-r>=SuperTabAlternateCompletion("\<lt>c-x>\<lt>c-o>")<cr>
    endif
endif
" }}}
" NERDCommenter {{{
let g:NERDCustomDelimiters = {
            \ 'elixir': { 'left': '#' },
            \ 'haskell': { 'left': '--' },
            \ 'arduino': { 'left': '//' }
            \}
let g:NERDRemoveExtraSpaces = 1
let g:NERDSpaceDelims = 1
" }}}
" delimitMate {{{
let g:delimitMate_expand_cr = 1
let g:delimitMate_expand_space = 1
" }}}
" neomake {{{
" let g:neomake_haskell_enabled_makers = ['ghcmod']
let g:neomake_haskell_enabled_makers = ['hdevtools']
let g:neomake_error_sign = {
    \ 'text': '✖',
    \ 'texthl': 'ErrorMsg',
    \ }
let g:neomake_warning_sign = {
    \ 'text': '☢',
    \ 'texthl': 'WarningMsg',
    \ }

let g:neomake_rust_enabled_makers = ['cargo']
let g:neomake_rust_cargo_maker = {
    \ 'exe': 'cargo',
    \ 'args': ['build'],
    \ 'append_file': 0,
    \ 'errorformat': '%Eerror%m,%Z\ %#-->\ %f:%l:%c',
    \ }
" }}}
" Racer {{{
let g:racer_cmd = "/opt/rust/cargo/bin/racer"
let g:racer_experimental_completer = 1
let g:rustfmt_fail_silently = 1
let g:rustfmt_autosave = 1
let g:deoplete#enable_at_startup=1
let g:deoplete#sources#rust#racer_binary='/opt/rust/cargo/bin/racer'
let g:deoplete#sources#rust#rust_source_path="/opt/rust/rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src"
inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"
" }}}
" }}}
