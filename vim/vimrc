" vimrc by Davs
" Vundle {{{
colorscheme desert

filetype off

set rtp+=~/.vim/bundle/vundle
call vundle#rc()

Bundle 'gmarik/vundle'

Bundle 'rhysd/clever-f.vim'
Bundle 'kien/ctrlp.vim'
Bundle 'Raimondi/delimitMate'
Bundle 'godlygeek/tabular'
Bundle 'tpope/vim-surround'
Bundle 'airblade/vim-rooter'

" snipMate
Bundle 'tomtom/tlib_vim'
Bundle 'MarcWeber/vim-addon-mw-utils'
Bundle 'garbas/vim-snipmate'

" Python
Bundle 'davidhalter/jedi-vim'
Bundle 'nvie/vim-flake8'
Bundle 'vim-scripts/Python-Syntax-Folding'

" Perl
Bundle 'DavsX/test_class_runner'

"Bundle 'scrooloose/nerdcommenter'
" Ruby
" Bundle 'vim-ruby/vim-ruby'
" Bundle 'tpope/vim-endwise'

filetype indent on
filetype plugin on
syntax on

" }}}
" Basic settings {{{
set nocp
set encoding=utf-8
set history=999                " history size
set lazyredraw                 " don't redraw when executing macros (good performance option)
set hidden                     " hide buffers instead of closing them
set modelines=4                " gives 4 lines for modelines (vim meta at the beginning/end of files)
set backspace=indent,eol,start " allow backspace in insert mode
"set autochdir                  " auto change directory when opening a file
set errorformat=%f:%l:%m
set autowrite
set nobackup
set noswapfile
set scrolloff=3                " when moving vertically set 3 lines to the cursor
set pastetoggle=<F2>
set mousehide
set number
set relativenumber
set splitbelow
set splitright
set nojoinspaces

set switchbuf=useopen,usetab,newtab
set winwidth=83

set complete-=i

" " Word wrap not in the middle of the word
set formatoptions=l
set lbr


" fast exiting insert mode; the removes the 1sec delay when not in GUI
set timeout timeoutlen=1000 ttimeoutlen=1000
if !has('gui_running')
    set ttimeoutlen=10
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif

let g:sh_noisk=1
" }}}
" cmdline {{{
set cmdheight=1             "command line size
set showcmd                 "show last command
set wildmenu                "cmdline completition
" }}}
" Leader {{{
let mapleader = ","
let maplocalleader = "\\"
" }}}
" Search {{{
set showmatch
set hlsearch
set incsearch

nnoremap <leader>. :nohl<CR>

set ignorecase
"set smartcase

" very magic mode for regexes
nnoremap <leader>/ /\v

vnoremap <C-r> "hy:%s/<C-r>h//gc<left><left><left>
vnoremap <C-R> "hy:%s/<C-r>h//g<left><left>
" }}}
" Indents {{{
set autoindent
set copyindent

vnoremap > >gv
vnoremap < <gv

nnoremap > >>
nnoremap < <<
" }}}
" Tabs {{{
set shiftwidth   =4             "number of spaces for indenting
set tabstop      =8             "number of spaces for tabs
set softtabstop  =4             "number of spaces for tabs while editing
set expandtab                   "autoinsert spaces instead of tabs
" }}}
" Statusline {{{
set statusline=
set statusline +=%1*\ %n\ %*            "buffer number
set statusline +=%5*%{&ff}%*            "file format
set statusline +=%3*%y%*                "file type
set statusline +=%4*\ %<%F%*            "full path
set statusline +=%2*%m%*                "modified flag
set statusline +=%1*%=%5l%*             "current line
set statusline +=%2*/%L%*               "total lines
set statusline +=%1*%4v\ %*             "virtual column number
set statusline +=%2*0x%04B\ %*          "character under cursor
" }}}
" Gui {{{
" ruler {{{
set ruler
set rulerformat=%m\ [%l/%L\ %v]
" }}}
set guifont=Liberation\ Mono\ 11

set guioptions=
set guioptions+=a "autoselect
set guioptions+=e "tabs
set guioptions+=g "grey menu items
set guioptions+=i "vim icon
set guioptions+=t "tearoff menu items

set guitablabel=%t          "show only filename in tabs

set t_Co=256
if has('gui_running')
    colorscheme desert
else
    colorscheme desert256
endif

hi CursorLine cterm=NONE ctermbg=239
hi Search cterm=underline

set title
set noerrorbells
set showmode
" }}}
" Basic maps {{{
nnoremap ; :
noremap <leader>w :w<CR>

"disable ex-mode
nnoremap Q <NOP>

"move to matching brace pair
nnoremap <tab> %

"split navigation
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

nnoremap <C-W>m <C-W>_<C-W><BAR>
nnoremap <C-W><C-M> <C-W><C-W><C-W>_<C-W><BAR>

inoremap <c-f> <c-x><c-f>

nnoremap <localleader>pr :e /home/davs/workspace/projects<CR>
nnoremap <localleader>pc :call ChangeToCurrentLine()<CR>

nnoremap ds<space> F<space>xf<space>x
" }}}
" Movement maps {{{
" H beginning of line; L end of line
nnoremap H ^
nnoremap L g_

vnoremap H ^
vnoremap L g_

onoremap H ^
onoremap L g_

" j/k move in wrapped lines too
nnoremap j gj
nnoremap k gk

vnoremap j gj
vnoremap k gk

" move to the top/middle/bottom of the screen
nnoremap gt :normal! H<CR>
nnoremap gb :normal! L<CR>
nnoremap gm :normal! M<CR>
" }}}
" Row/column highlight {{{
noremap <F3> :set cursorline!<CR>
noremap <F4> :set cursorcolumn!<CR>
" }}}
" Tabs {{{
noremap <c-t> :tabnew<CR>
nnoremap <leader>n :tabprev<CR>
nnoremap <leader>m :tabnext<CR>
" }}}
" Buffers {{{
nnoremap <leader>j :bp<CR>
nnoremap <leader>k :bn<CR>
" }}}
" Filetype {{{
" EveryFile {{{
augroup all_file_type
    autocmd!
    autocmd WinEnter,FocusGained,BufEnter * setlocal relativenumber
    autocmd WinLeave,FocusLost,BufLeave * setlocal norelativenumber
augroup END
" }}}
" QuickFix {{{
augroup quickfix
    autocmd!
    autocmd FileType qf nnoremap <buffer> <c-m> <CR>
    autocmd FileType qf nnoremap <buffer> <CR> <CR>
    autocmd FileType qf nnoremap <buffer> o <CR><C-W><C-P>
    autocmd FileType qf nnoremap <buffer> q :lclose<CR>:cclose<CR>
    autocmd FileType qf nnoremap <buffer> <ESC> :lclose<CR>cclose<CR>
    autocmd FileType qf nnoremap <buffer> <c-J> <CR><ESC>:lclose<CR>:cclose<CR>
augroup END
" }}}
" Perl {{{
augroup filetype_perl
    autocmd!
    autocmd BufRead,BufNewFile *.pm  setfiletype perl
    autocmd BufRead,BufNewFile *.pl  setfiletype perl
    autocmd BufRead,BufNewFile *.t   setfiletype perl

    autocmd BufNewFile *.pl 0r ~/.vim/skeleton/perl.script
    autocmd BufNewFile *.pm 0r ~/.vim/skeleton/perl.package
    autocmd BufNewFile *.t 0r ~/.vim/skeleton/perl.test

    autocmd BufWritePre * if &filetype=='perl' | %s/\s\+$//e | endif

    autocmd BufRead,BufWritePre,FileType perl execute ":Rooter"

    autocmd BufRead,BufNewFile *.pm  setlocal filetype=perl
    autocmd BufRead,BufNewFile *.pl  setlocal filetype=perl
    autocmd BufRead,BufNewFile *.t   setlocal filetype=perl

    autocmd FileType perl setlocal nowrap
    autocmd FileType perl setlocal complete-=i
    "autocmd FileType perl setlocal foldlevel=1
    autocmd FileType perl setlocal foldlevelstart=20
    autocmd FileType perl setlocal foldnestmax=2
    autocmd FileType perl let perl_include_pod = 1
    autocmd FileType perl let perl_extended_vars = 1
    autocmd FileType perl let perl_fold = 1
    autocmd FileType perl let perl_fold_blocks = 1
    
    autocmd FileType perl setlocal iskeyword-=:

    autocmd FileType perl setlocal errorformat=%f:%l:%m
    "autocmd FileType perl setlocal makeprg=~/bin/efm_perl.pl
    autocmd FileType perl setlocal makeprg=prove

    autocmd FileType perl nnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType perl nnoremap <buffer> <leader>cu :call UnComment('# ')<CR>

    autocmd FileType perl vnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType perl vnoremap <buffer> <leader>cu :call UnComment('# ')<CR>

    autocmd FileType perl nnoremap <buffer> <leader>idd <ESC>ause Data::Dumper;<CR>local $Data::Dumper::Maxdepth = 2;<CR>say STDERR Dumper ;<LEFT>

    autocmd FileType perl nnoremap <buffer> <leader>gs :call PerlSubGrep()<CR>
    autocmd FileType perl nnoremap <buffer> <leader>gl :call PerlSubGrepLike()<CR>

    autocmd FileType perl nnoremap <buffer> <leader>rr :!perl %<CR>

    autocmd FileType perl nnoremap <buffer> <leader>rf :PerlTestFile<CR>
    autocmd FileType perl nnoremap <buffer> <leader>rt :PerlTestFile<CR>
    autocmd FileType perl nnoremap <buffer> <leader>rs :PerlTestSub<CR>
    autocmd FileType perl nnoremap <buffer> <leader>ra :ProveTestAll<CR>

    " autocmd FileType perl nnoremap <buffer> <leader>rf :call RunPerlTest('file')<CR>
    " autocmd FileType perl nnoremap <buffer> <leader>ra :call RunPerlTest('')<CR>
augroup END
" }}}
" Python {{{
augroup filetype_python
    autocmd!

    autocmd BufWritePre * if &filetype=='python' | %s/\s\+$//e | endif
    autocmd BufEnter,BufRead,BufWritePre,FileReadPost,FileType python execute ":Rooter"

    autocmd BufNewFile *.py 0r ~/.vim/skeleton/python.script
    autocmd BufRead,BufNewFile *.py setfiletype python

    "autocmd FileType python setlocal compiler=nose
    autocmd FileType python setlocal errorformat=%f:%l:\ fail:\ %m,%f:%l:\ error:\ %m,%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m,%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m
    autocmd FileType python setlocal makeprg=nosetests\ --with-machineout
    
    autocmd FileType python let python_hightlight_all=1
    autocmd FileType python setlocal foldlevelstart=20
    autocmd FileType perl setlocal nowrap
    autocmd FileType perl setlocal complete-=i

    "autocmd FileType python setlocal iskeyword+=.
    autocmd FileType python setlocal wildignore+=*.pyc

    autocmd FileType python nnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType python nnoremap <buffer> <leader>cu :call UnComment('# ')<CR>

    autocmd FileType python vnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType python vnoremap <buffer> <leader>cu :call UnComment('# ')<CR>

    autocmd FileType python nnoremap <buffer> <leader>pf :call Flake8()<CR>
    autocmd FileType python nnoremap <buffer> <leader>pp :call Pep8()<CR>

    autocmd FileType python nnoremap <buffer> <leader>rr :!python %<CR>

    autocmd FileType python nnoremap <buffer> <leader>ra :call RunPythonTest('all')<CR>
    autocmd FileType python nnoremap <buffer> <leader>rf :call RunPythonTest('file')<CR>
    autocmd FileType python nnoremap <buffer> <leader>rc :call RunPythonTest('class')<CR>
    autocmd FileType python nnoremap <buffer> <leader>rm :call RunPythonTest('method')<CR>
augroup END
" }}}
" HTML {{{
augroup filetype_html
    autocmd!
    autocmd BufRead,BufNewFile *.tt  setfiletype html

    autocmd BufRead,BufNewFile *.tt setlocal foldmethod=marker

    autocmd FileType html setlocal foldlevel=99
    autocmd FileType html setlocal shiftwidth=2
    autocmd FileType html setlocal tabstop=2
    autocmd FileType html setlocal softtabstop=2
    autocmd FileType html setlocal expandtab

    autocmd FileType html highlight link htmlLink text
    autocmd FileType html syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 keepend contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLinkText,javaScript,@htmlPreproc
    autocmd FileType html syn match htmlLinkText contained contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLinkText,javaScript,@htmlPreproc "^\s*\zs.\{-}\ze\s*$"
    autocmd FileType html syn match htmlLinkText contained contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLinkText,javaScript,@htmlPreproc "\S.\{-}\ze\s*$"
    autocmd FileType html highlight def link htmlLinkText Underlined

    "autocmd BufRead,BufWritePre * if &filetype == 'html' | call RunAutoIndent() | endif

    autocmd FileType html iabbrev <buffer> nbsp &nbsp;
augroup END
" }}}
" vim {{{
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
    autocmd FileType vim setlocal foldlevel=0

    "autocmd BufWritePre * if &filetype=='vim' | %s/\s\+$//e | endif
    autocmd FileType vim noremap <buffer> <leader>ss  :w<CR>:source %<CR>:e <CR>

    autocmd FileType vim nnoremap <buffer> <leader>cc :call Comment('" ')<CR>
    autocmd FileType vim nnoremap <buffer> <leader>cu :call UnComment('" ')<CR>

    autocmd FileType vim vnoremap <buffer> <leader>cc :call Comment('" ')<CR>
    autocmd FileType vim vnoremap <buffer> <leader>cu :call UnComment('" ')<CR>
augroup END
" }}}
" sh {{{
augroup filetype_sh
    autocmd!

    autocmd FileType sh nnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType sh nnoremap <buffer> <leader>cu :call UnComment('# ')<CR>

    autocmd FileType sh vnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType sh vnoremap <buffer> <leader>cu :call UnComment('# ')<CR>
augroup END
" }}}
" CursorLine {{{ 
augroup CursorLine
    autocmd!
    autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
augroup END
" }}}
" ruby {{{
augroup filetype_ruby
    autocmd!

    autocmd BufRead,BufNewFile *.rb setfiletype ruby

    autocmd BufWritePre * if &filetype=='ruby' | %s/\s\+$//e | endif

    autocmd BufRead,BufWritePre,FileType ruby execute ":Rooter"

    autocmd FileType ruby,eruby let ruby_fold = 1
    autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1 
    autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

    autocmd FileType ruby,eruby setlocal shiftwidth=2
    autocmd FileType ruby,eruby setlocal softtabstop=2
    autocmd FileType ruby,eruby setlocal expandtab

    autocmd FileType ruby nnoremap <buffer> <leader>rr :!ruby %<CR>

    autocmd FileType ruby nnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType ruby nnoremap <buffer> <leader>cu :call UnComment('# ')<CR>

    autocmd FileType ruby vnoremap <buffer> <leader>cc :call Comment('# ')<CR>
    autocmd FileType ruby vnoremap <buffer> <leader>cu :call UnComment('# ')<CR>
augroup END
" }}}
" }}}
" vimrc {{{
noremap <leader>se :tabnew $MYVIMRC<CR>
noremap <leader>ss :source $MYVIMRC<CR>
noremap <leader>sl :execute getline(".")<CR>
" }}}
" Folding {{{
set foldmethod   =indent
set foldlevel    =20 "open folds by default

noremap <space> za
" }}}
" Functions {{{
" ChangeToCurrentLine {{{
function! ChangeToCurrentLine()
    let row = getline(".")
    echom row
    execute ":cd ".row
    execute ":e ".row
endfunction
" }}}
" ToggleColorColumn {{{
set colorcolumn=80
let g:colorcolumn_set = 1
highlight ColorColumn guibg=#333333 ctermbg=8

noremap <leader>tcc :call ToggleColorColumn()<CR>

function! ToggleColorColumn()
    if g:colorcolumn_set == 1
        set colorcolumn=0
        let g:colorcolumn_set = 0
    else
        set colorcolumn=80
        let g:colorcolumn_set = 1
    endif
endfunction
" }}}
" ToggleLastStatus {{{
set laststatus=1
let g:laststatus_value = 1

noremap <leader>tls :call ToggleLastStatus()<CR>

function! ToggleLastStatus()
    if g:laststatus_value == 1
        set laststatus=2
        let g:laststatus_value = 2
    else
        set laststatus=1
        let g:laststatus_value = 1
    endif
endfunction
" }}}
" PerlSubGrep {{{
function! PerlSubGrep()
    let l:word = expand("<cword>")
    execute 'lvimgrep /^\s*\<sub '. l:word .'\>/j **/*.pm'
    lopen
endfunction
" }}}
" PerlSubGrepLike {{{
function! PerlSubGrepLike()
    let l:word = expand("<cword>")
    execute 'lvimgrep /^\s*sub '. l:word .'/j **/*.pm'
    lopen
endfunction
" }}}
" RunPythonTest {{{
function! RunPythonTest(mode)
    let l:path = expand('%')

    let l:result = 0

    if a:mode == 'file'
        let l:result = RunTest(l:path)
    elseif a:mode == 'class'
        let l:class = GetPythonClassName()
        let l:result = RunTest(l:path . ":" . l:class)
    elseif a:mode == 'method'
        let l:class = GetPythonClassName()
        let l:method = GetPythonMethodName()
        let l:result = RunTest(l:path .":". l:class .".". l:method)
    else
        let l:result = RunTest('')
    endif

    if l:result == 0
        let l:line = getqflist()[0]['text']

        let l:list = matchlist(l:line, '\vFile "([^"]*)", line (\d+)')
        if !empty(l:list)
            let l:file = l:list[1]
            let l:line_no = l:list[2]

            if l:file =~# getcwd()
                if l:file == expand('%:p')
                    execute "normal! ".l:line_no."G"
                else
                    execute "badd +".l:line_no." ".l:file
                    execute "vert sbuffer " . l:file
                    execute "normal! ".l:line_no."G"
                endif
            endif
            copen
            wincmd k
        else
            let l:bufname = fnamemodify(buffer_name(getqflist()[0]['bufnr']), ':p')
            if l:bufname =~# getcwd()
                cc!
            else
                copen
            endif
        endif
    endif
endfunction
" }}}
" RunPerlTest {{{
function! RunPerlTest(mode)
    let l:path = expand('%')

    let l:result = 0

    if a:mode == 'file'
        let l:result = RunTest(l:path)
    "elseif a:mode == 'class'
        "let l:class = GetPythonClassName()
        "let l:result = RunTest(l:path . ":" . l:class)
    "elseif a:mode == 'method'
        "let l:class = GetPythonClassName()
        "let l:method = GetPythonMethodName()
        "let l:result = RunTest(l:path .":". l:class .".". l:method)
    else
        let l:result = RunTest('t/')
    endif

    if l:result == 0
        let l:line = getqflist()[0]['text']

        let l:list = matchlist(l:line, '\vFile "([^"]*)", line (\d+)')
        if !empty(l:list)
            let l:file = l:list[1]
            let l:line_no = l:list[2]

            if l:file =~# getcwd()
                if l:file == expand('%:p')
                    execute "normal! ".l:line_no."G"
                else
                    execute "badd +".l:line_no." ".l:file
                    execute "vert sbuffer " . l:file
                    execute "normal! ".l:line_no."G"
                endif
            endif
            copen
            wincmd k
        else
            let l:bufname = fnamemodify(buffer_name(getqflist()[0]['bufnr']), ':p')
            if l:bufname =~# getcwd()
                cc!
            else
                copen
            endif
        endif
    endif
endfunction
" }}}
" GetPythonMethodName {{{
function! GetPythonMethodName()
    let l:line_no = search('\v^\s*def ','bcnW')

    if l:line_no > 0
        let l:line = getline(l:line_no)
        let l:list = matchlist(l:line, '\v^\s*def ([0-9a-zA-Z_]+)')

        if !empty(l:list)
            let l:method = l:list[1]
            return l:method
        else
            throw "Method name did not match"
        endif
    else
        throw "No method found"
    endif
endfunction
" }}}
" GetPythonClassName {{{
function! GetPythonClassName()
    let l:line_no = search('\v^\s*class ','bcnW')

    if l:line_no > 0
        let l:line = getline(l:line_no)
        let l:list = matchlist(l:line, '\v^\s*class ([0-9a-zA-Z_]+)')

        if !empty(l:list)
            let l:class = l:list[1]
            return l:class
        else
            throw "Class name did not match"
        endif
    else
        throw "No class found"
    endif
endfunction
" }}}
" RunTest {{{
function! RunTest(args)
    silent w

    if a:args == ''
        silent make!
    else
        execute ":silent make! " . a:args
    endif

    redraw!

    hi GreenBar term=reverse ctermfg=yellow ctermbg=green guifg=yellow guibg=green

    if getqflist() == []
        echohl GreenBar
        echon repeat(" ", &columns - 30)
        echohl None
        return 1
    endif
    return 0
endfunction
" }}}
" Pep8 {{{
function! Pep8()
    let l:winview = winsaveview()
    write
    execute ":0r !autopep8 %"
    execute ":normal! jVGd"
    call winrestview(l:winview)
endfunction
" }}}
" Comment {{{
function! Comment(mark)
    let l:hlsearch = &hlsearch
    set nohlsearch
    if getline('.') !~ '\v^\s*$'
        execute ':silent! s/\v^\s*/&'.a:mark.'/'
    endif
    let &hlsearch = l:hlsearch
endfunction
" }}}
" UnComment {{{
function! UnComment(mark)
    let l:hlsearch = &hlsearch
    set nohlsearch
    if getline('.') !~ '\v^\s*$'
        execute ':silent! s/\v^(\s*)'.a:mark.'/\1/'
    endif
    let &hlsearch = l:hlsearch
endfunction
" }}}
" CloseHiddenbuffers {{{
nnoremap <leader>cl :call CloseHiddenBuffers()<CR>
function! CloseHiddenBuffers()
    let visible_buffers = {}

    for tab in range(1, tabpagenr('$'))
        for buffer in tabpagebuflist(tab)
            let visible_buffers[buffer] = 1
        endfor
    endfor

    for buffer in range(1, bufnr('$'))
        if bufloaded(buffer) && !has_key(visible_buffers, buffer)
            execute 'bd ' . buffer
        endif
    endfor
endfunction
" }}}
" DeleteFile {{{
function! DeleteFile()
    let l:path = expand('%:p')
    let l:confirm = input('Delete '.l:path.'? [YES]: ')
    if l:confirm ==# 'YES'
        call delete(l:path) | bdelete!
    endif
endfunction
" }}}
" }}}
" Plugin settings {{{
" Tabularize {{{
vnoremap <leader>ah :Tabularize /^.\{-}\ze=>/l0l0<CR>
vnoremap <leader>a= :Tabularize /^.\{-}\ze=/l0l0<CR>
vnoremap <leader>a, :Tabularize /^.\{-}\ze,/l0l0<CR>
vnoremap <leader>aa :Tabularize /
vnoremap <leader>af :Tabularize /^.\{-}\ze/l0l0<left><left><left><left><left>

nnoremap <leader>ah :Tabularize /^.\{-}\ze=>/l0l0<CR>
nnoremap <leader>a= :Tabularize /^.\{-}\ze=/l0l0<CR>
nnoremap <leader>a, :Tabularize /^.\{-}\ze,/l0l0<CR>
nnoremap <leader>aa :Tabularize /
nnoremap <leader>af :Tabularize /^.\{-}\ze/l0l0<left><left><left><left><left>
" }}}
" ctrlp {{{
set runtimepath^=~/.vim/bundle/ctrlp.vim
let g:ctrlp_custom_ignore = {
    \ 'dir': '\v(\.git|virtualenv)',
    \ 'file': '\v(__init__\.py|\.pyc)$',
    \ }

nnoremap <leader>, :CtrlP<CR>
" }}}
" Clever-f {{{
let g:clever_f_across_no_line = 0
" }}}
" Rooter {{{
let g:rooter_patterns = [ '.git/', '.vimproject' ]
let g:rooter_manual_only = 0
let g:rooter_change_directory_for_non_project_files = 0
" }}}
" vim-jedi {{{
let g:jedi#goto_assignments_command = ""
let g:jedi#goto_definitions_command = ""
let g:jedi#documentation_command    = "K"
let g:jedi#usages_command           = "<leader>gs"
let g:jedi#completions_command      = "<C-Space>"
let g:jedi#rename_command           = ""
let g:jedi#show_call_signatures     = "1"
let g:jedi#popup_on_dot             = 0
" }}}
" snippets {{{
let g:snips_author = "David Kovacs [DavsX]"
let g:snips_email = "kovdavid@gmail.com"
let g:snips_github = "http://github.com/DavsX"
" }}}
" test_class_runner {{{
let $TEST_PRETTY_COLOR_NAME  = 'bright_green'
let $TAP_ELAPSED_FORMAT  = '%t1 elapsed'
let g:test_class_path_folder = 'tests'
let g:test_class_path_prefix = 'Test'
let g:test_class_perl_args   = '-MTest::Pretty -Ilib -It/lib -It/tests'
let g:test_class_prove_args  = '-Ilib -It/lib -It/tests -j9 --timer'
" }}}
" }}}
